import ContentDAOContract from "../constants/ABI/ContentDAO.json";


import { useCallback } from "react";
import {
  useWeb3ModalAccount,
  useWeb3ModalProvider,
} from "@web3modal/ethers/react";
import { getContentDAOContract } from "../constants/contract";
import { getProvider } from "../constants/provider";
import { toast } from "react-toastify";
import { isSupportedChain } from "../utils";


const useContentDAO = () => {
  const { chainId } = useWeb3ModalAccount();
  const { walletProvider } = useWeb3ModalProvider();

  const joinDAO = useCallback(
    async (stakeAmount: number) => {
      if (chainId === undefined)
        return toast.error("Please connect your wallet first");
      if (!isSupportedChain(chainId)) return toast.error("Wrong network");

      const readWriteProvider = getProvider(walletProvider);
      const signer = await readWriteProvider.getSigner();
      const contract = getContentDAOContract(signer);

      try {
        const transaction = await contract.joinDAO(stakeAmount);
        console.log("transaction: ", transaction);

        const receipt = await transaction.wait();
        console.log("receipt: ", receipt);
      } catch (error: unknown) {
        console.log(error);
      }
    },
    [chainId, walletProvider]
  );

  const leaveDAO = useCallback(async () => {
    if (chainId === undefined)
      return toast.error("Please connect your wallet first.");
    if (!isSupportedChain(chainId)) return toast.error("Wrong network");

    const readWriteProvider = getProvider(walletProvider);
    const signer = await readWriteProvider.getSigner();
    const contract = getContentDAOContract(signer);

    try {
      const transaction = await contract.leaveDAO();
      console.log("transaction: ", transaction);

      const receipt = await transaction.wait();
      console.log("receipt: ", receipt);
    } catch (error: unknown) {
      console.log(error);
    }
  }, [chainId, walletProvider]);

  const createProposal = useCallback(
    async (name: string, description: string, duration: number) => {
      if (chainId === undefined)
        return toast.error("Please connect your wallet first");
      if (!isSupportedChain(chainId)) return toast.error("Wrong network");

      const readWriteProvider = getProvider(walletProvider);
      const signer = await readWriteProvider.getSigner();
      const contract = getContentDAOContract(signer);

      try {
        const transaction = await contract.createProposal(
          name,
          description,
          duration
        );
        console.log("transaction: ", transaction);

        const receipt = await transaction.wait();
        console.log("receipt: ", receipt);
      } catch (error: unknown) {
        console.log(error);
      }
    },
    [chainId, walletProvider]
  );

  // Add other functions for interacting with the ContentDAO contract

  const voteForProposal = useCallback(
    async (proposalId: number) => {
      if (chainId === undefined)
        return toast.error("Please connect your wallet first");
      if (!isSupportedChain(chainId)) return toast.error("Wrong network");

      const readWriteProvider = getProvider(walletProvider);
      const signer = await readWriteProvider.getSigner();
      const contract = getContentDAOContract(signer);

      try {
        const transaction = await contract.voteForProposal(proposalId);
        console.log("transaction: ", transaction);

        const receipt = await transaction.wait();
        console.log("receipt: ", receipt);
      } catch (error: unknown) {
        console.log(error);
      }
    },
    [chainId, walletProvider]
  );

  const voteAgainstProposal = useCallback(
    async (proposalId: number) => {
      if (chainId === undefined)
        return toast.error("Please connect your wallet first");
      if (!isSupportedChain(chainId)) return toast.error("Wrong network");

      const readWriteProvider = getProvider(walletProvider);
      const signer = await readWriteProvider.getSigner();
      const contract = getContentDAOContract(signer);

      try {
        const transaction = await contract.voteAgainstProposal(proposalId);
        console.log("transaction: ", transaction);

        const receipt = await transaction.wait();
        console.log("receipt: ", receipt);
      } catch (error: unknown) {
        console.log(error);
      }
    },
    [chainId, walletProvider]
  );

  const executeProposal = useCallback(
    async (proposalId: number) => {
      if (chainId === undefined)
        return toast.error("Please connect your wallet first");
      if (!isSupportedChain(chainId)) return toast.error("Wrong network");

      const readWriteProvider = getProvider(walletProvider);
      const signer = await readWriteProvider.getSigner();
      const contract = getContentDAOContract(signer);

      try {
        const transaction = await contract.executeProposal(proposalId);
        console.log("transaction: ", transaction);

        const receipt = await transaction.wait();
        console.log("receipt: ", receipt);
      } catch (error: unknown) {
        console.log(error);
      }
    },
    [chainId, walletProvider]
  );

  const getProposals = useCallback(async () => {
    if (chainId === undefined)
      return toast.error("Please connect your wallet first");
    if (!isSupportedChain(chainId)) return toast.error("Wrong network");

    const readWriteProvider = getProvider(walletProvider);
    const signer = await readWriteProvider.getSigner();
    const contract = getContentDAOContract(signer);

    try {
      const proposals = await contract.getProposals();
      return proposals;
    } catch (error: unknown) {
      console.log(error);
    }
  }, [chainId, walletProvider]);

  return {
    joinDAO,
    leaveDAO,
    createProposal,
    voteForProposal,
    voteAgainstProposal,
    executeProposal,
    getProposals,
  };
};

export default useContentDAO;



import React from "react";
import useContentDAO from "../../../hooks/useDAO";

const ProposalsTable = () => {
  const { getProposals } = useContentDAO();
  const [proposals, setProposals] = useState([]);

  useEffect(() => {
    getProposals().then((proposals) => setProposals(proposals));
  }, [getProposals]);

  return (
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Description</th>
          <th>Duration</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody>
        {proposals.map((proposal) => (
          <tr >
            <td>{proposal.name}</td>
            <td>{proposal.description}</td>
            <td>{proposal.duration}</td>
            <td>{proposal.status}</td>
            <td>{proposal.voteFor}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default ProposalsTable;